"""
Друзья друзей
Теория шести рукопожатий — социологическая теория, согласно которой любые два человека на Земле разделены не более,
чем пятью уровнями общих знакомых (и, соответственно, шестью уровнями связей).
Формальная математическая формулировка теории: диаметр графа знакомств не превышает 6.
Мы не станем так сильно углубляться в дружественные связи и пока нам хватит только двух уровней.
Напишите программу, которая по списку дружественных пар для каждого человека определяет список «друзей 2-го уровня».

Формат ввода:
    В каждой строке записывается два имени.
    Окончанием ввода служит пустая строка.

Формат вывода:
    Выведите список всех людей и их «друзей 2-го уровня» в формате «Человек: Друг1, Друг2, ...».
    Список людей и друзей в каждой строке требуется вывести в алфавитном порядке без повторений.
"""

import collections


# вынес обновление словаря в отдельный метод, на вход подается текущее состояние словаря, новое значение
def update(dict_old_version, new_value):
    update_dict = dict_old_version
    update_dict.update({new_value: 1})
    return update_dict


friends = dict()
# считываем поступившие на ход строки, пока не будет пустой строки
while (two_names := input()) != "":
    # разделяем строку по пробелу
    split_two_names = two_names.split(" ")
    # проходимся по элементам разделённой строки
    # и составляем словарь словарей в котором будут "друзья 1 уровня" п.{"Друг": {"Друг_1: 1", "Друг_2: 1"}}
    for name in split_two_names:
        # в цикле создаём пустой словарь с фамилий первого из двух друзей
        friends[name] = friends.get(name, {})
        # далее проверяем, если индекс первого элемента, то с помощью метода передаём данные текущего состояния,
        # и заносим в словарь как "друга 1 уровня" элемент со второй позиции
        if split_two_names.index(name) == 0:
            friends[name] = update(friends.get(name), split_two_names[1])
        # аналогично для элемента 2-й позиции.
        elif split_two_names.index(name) == 1:
            friends[name] = update(friends.get(name), split_two_names[0])

# создаём дополнительный словарь, в котором основываясь на словарь "друзей 1 ур.",
# будем составлять словарь "друзей 2ур."
friends_2 = dict()
# в цикле проходимся по словарю друзей
for i in friends:
    # создаём пустой словарь
    friends_2[i] = friends_2.get(i, {})
    # в цикле проходимся по словарю "друзей 1 ур."
    for j in friends[i]:
        # далее смотрим друзей друга, и добавляем их в словарь "друзей 2ур." - friends_2
        for k in friends.get(j):
            friends_2[i].update({k: 1})

# двумя следующими циклами производим очистку
# от одинаковых элементов в ключе и значении
for i in friends_2:
    for j in friends_2[i]:
        # если фамилия ключа == фамилии значения, удаляем элемент
        if i == j:
            del friends_2[i][j]
            break
# от "друзей 1 ур."
for i in friends_2:
    # в цикле смотрим в словарь из первого уровня друзей
    for j in friends[i]:
        # сравниваем с друзьями 2-го уровня, при совпадении элемент из "друзей 2ур." - удаляем
        for k in friends_2[i]:
            if k == j:
                del friends_2[i][k]
                break
# цикл в котором выводим информацию, согласно шаблону
for i in sorted(friends_2):
    print(f"{i}:", sep="", end=" ")
    for j in sorted(friends_2[i]):
        [last] = collections.deque(sorted(friends_2[i]), maxlen=1)
        if j == last:
            print(f"{j}", end="")
        else:
            print(f"{j}", end=", ")
    print()
