"""
        Польский калькулятор

Напишите программу, которая производит вычисление выражения, записанного в обратной польской нотации (ОПН).

В ОПН нет ни скобок, ни приоритета операторов («умножение раньше сложения»).

Чтобы прочитать выражение, записанное в таком формате, нужно просматривать выражение строго последовательно.
Вводимые значения последовательно добавляются в стек. Когда встречается символ операции,
то из стека извлекаются последние положенные туда значения, с ними проделывается эта операция
и результат возвращается в стек.

Если для операции важен порядок значений, с которыми она производится, то первым идёт число, лежавшее в стеке глубже.
В частности, если операция — вычитание, то из предпоследнего числа в стеке вычитается последнее, а не наоборот.

Изначально стек пустой, в результате полного вычисления выражения
 в нём должно остаться одно значение — результат вычислений.

Первый пример следует читать так: в стек последовательно добавляются значения 7 2 3, а затем встречаем знак операции *.
Тогда значения 2 и 3 извлекаются, перемножаются, результат 6 кладётся обратно в стек.
Следующий знак извлекает из стека два оставшихся в нём значения 7 и 6, вычитает одно из другого
и кладёт результат снова в стек. Выражение закончилось, в стеке одно число — 1, это и есть результат вычисления.

Формат ввода:
    Вводится одна строка, содержащая разделённые пробелами целые числа и знаки операций -, +, *
    которые вместе составляют корректное выражение в обратной польской нотации.

Формат вывода:
    Выводится одно целое число — результат вычисления выражения.
"""


# в методе, при встрече первого знака, берем два предыдущих числа и совершаем операцию над ними, помещаем результат
# в ячейку i и удаляем числа и знак и выходим из цикла, возвращая новый лист
def do_somthing(list_opn):
    new_list_opn = []
    for i, el in enumerate(list_opn):
        if el == "*":
            # print("/", list_opn)
            new_list_opn = list_opn.copy()
            new_list_opn.pop(i)
            new_list_opn.insert(i, int(list_opn[i - 2]) * int(list_opn[i - 1]))
            new_list_opn.pop(i - 1)
            new_list_opn.pop(i - 2)
            break

        elif el == "+":
            new_list_opn = list_opn.copy()
            new_list_opn.pop(i)
            new_list_opn.insert(i, int(list_opn[i - 2]) + int(list_opn[i - 1]))
            new_list_opn.pop(i - 1)
            new_list_opn.pop(i - 2)
            break
        elif el == "-":
            new_list_opn = list_opn.copy()
            new_list_opn.pop(i)
            new_list_opn.insert(i, int(list_opn[i - 2]) - int(list_opn[i - 1]))
            new_list_opn.pop(i - 1)
            new_list_opn.pop(i - 2)
            break
    # print(new_list_opn, 'ret')
    return new_list_opn


# получаю строку в записи ОПН
opn = input()
# разделяю её по пробелу
base = opn.split(" ")
# в цикле пока у меня не останется один элемент, вызываю метод
while len(base) > 1:
    base = do_somthing(base)
# печатаю первый элемент листа, это будет результат работы программы
print(base[0])
